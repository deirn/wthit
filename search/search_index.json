{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WTHIT Documentation","text":"<p>Welcome to WTHIT documentation!</p>"},{"location":"config/blacklisting/","title":"Blacklisting Blocks and Entities","text":"<p>To blacklist some blocks from WTHIT, create a block tag called <code>waila:blacklist</code>. See an entry about datapack tags on Minecraft Wiki here.</p> <p>For example, to make stone block blacklisted you make the tag contains the following</p> <code>data/waila/tags/blocks/blacklist.json</code> <pre><code>{\n\"values\": [\n\"minecraft:stone\"\n]\n}\n</code></pre> <p>The same can be done for entity types</p> <code>data/waila/tags/entity_types/blacklist.json</code> <pre><code>{\n\"values\": [\n\"minecraft:pig\"\n]\n}\n</code></pre>"},{"location":"plugin/adding_to_blacklist/","title":"Adding to Blacklist","text":"<p>Unlike overriding object to disable the tooltip, adding it  to the blacklist means the player can override those values.</p> <p>You can add blocks, block entity types, and entity types to the blacklist.</p> <pre><code>public class MyWailaPlugin implements IWailaPlugin {\n@Override\npublic void register(IRegistrar registrar) {\nregistrar.addBlacklist(\nBlocks.OAK_PLANKS,\nBlocks.CRAFTING_TABLE\n);\n\nregistrar.addBlacklist(\nEntityType.MINECART\n);\n}\n}\n</code></pre>"},{"location":"plugin/adding_to_blacklist/#using-tag-to-add-to-blacklist","title":"Using tag to add to blacklist","text":"<p>This method only viable if your mod also adds new blocks and/or entities since this would require the tag to be present on the server. Create a tag called <code>waila:blacklist</code>.</p> <p>For example, to make stone block blacklisted you make the tag contains the following</p> <code>data/waila/tags/blocks/blacklist.json</code> <pre><code>{\n\"values\": [\n\"minecraft:stone\"\n]\n}\n</code></pre> <p>The same can be done for entity types</p> <code>data/waila/tags/entity_types/blacklist.json</code> <pre><code>{\n\"values\": [\n\"minecraft:pig\"\n]\n}\n</code></pre>"},{"location":"plugin/config/","title":"Plugin Configuration","text":"<p>Not everyone wanted every feature from your plugin, so making them configurable is recommended.</p> <p><code>IRegistrar</code> has multiple methods for registering a config option:</p>"},{"location":"plugin/config/#addconfig","title":"<code>addConfig</code>","text":"<p>This method registers a local-only option. This is recommended for cosmetic-only options.</p>"},{"location":"plugin/config/#addsyncedconfig","title":"<code>addSyncedConfig</code>","text":"<p>This method registers a server option. The server will force connected clients to have the same value.  If the client is connected to a server that doesn't have WTHIT, its value will be locked to the specified client-only value.</p>"},{"location":"plugin/config/#addmergedconfig","title":"<code>addMergedConfig</code>","text":"<p>Like <code>addSyncedConfig</code>, the server will send its option value to connected clients but it won't force the value. When the server enabled the option, the client can freely disable it for their side. Recommended for toggle for a feature that works client-only.</p>"},{"location":"plugin/config/#addmergedsyncedconfig","title":"<code>addMergedSyncedConfig</code>","text":"<p>This is pretty much the same as <code>addMergedConfig</code> but with the additional rule that the server needs to have WTHIT installed,  otherwise, the option will be locked to a predetermined value. Recommended for toggle for a feature that needs server-synced data to work properly.</p>"},{"location":"plugin/disabling_tooltip/","title":"Disabling Tooltip","text":""},{"location":"plugin/disabling_tooltip/#disabling-tooltip-for-certain-objects","title":"Disabling Tooltip for Certain Objects","text":"<p>Sometimes you want to disable the tooltip for showing altogether. To do that, WTHIT contains a static variable on <code>I*ComponentProvider</code> that we can use as a return value for <code>getOverride</code>.</p> <pre><code>public class BlockOverride implements IBlockComponentProvider {\n@Override\npublic BlockState getOverride(IBlockAccessor accessor, IPluginConfig config) {\nreturn EMPTY_BLOCK_STATE;\n}\n}\n</code></pre> <pre><code>public class EntityOverride implements IEntityComponentProvider {\n@Override\npublic Entity getOverride(IEntityAccessor accessor, IPluginConfig config) {\nreturn EMPTY_ENTITY;\n}\n}\n</code></pre>"},{"location":"plugin/getting_started/","title":"Getting Started","text":""},{"location":"plugin/getting_started/#gradle-setup","title":"Gradle Setup","text":"<p>To get started making a WTHIT plugin, add the following to your <code>build.gradle</code></p>"},{"location":"plugin/getting_started/#adding-repository","title":"Adding Repository","text":"<pre><code>repositories {\nmaven { url \"https://maven.bai.lol\" }\n}\n</code></pre>"},{"location":"plugin/getting_started/#declaring-dependencies","title":"Declaring Dependencies","text":"FabricForgeQuiltArchitecturyVanillaGradle Multiplatform <pre><code>dependencies {\n  // compile against the API\n  modCompileOnly \"mcp.mobius.waila:wthit-api:fabric-${wthitVersion}\"\n\n  // run against the full jar\n  modRuntimeOnly \"mcp.mobius.waila:wthit:fabric-${wthitVersion}\"\n  modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\"\n}\n</code></pre> <pre><code>buildscript {\n  dependencies {\n    classpath \"org.spongepowered:mixingradle:0.7.+\"\n  }\n}\n\napply plugin: \"org.spongepowered.mixin\"\n\ndependencies {\n  // compile against the API\n  compileOnly fg.deobf(\"mcp.mobius.waila:wthit-api:forge-${wthitVersion}\")\n\n  // run against the full jar\n  runtimeOnly fg.deobf(\"mcp.mobius.waila:wthit:forge-${wthitVersion}\")\n  runtimeOnly fg.deobf(\"lol.bai:badpackets:forge-0.2.0\")\n}\n</code></pre> <pre><code>dependencies {\n  // compile against the API\n  modCompileOnly \"mcp.mobius.waila:wthit-api:quilt-${wthitVersion}\"\n\n  // run against the full jar\n  modRuntimeOnly \"mcp.mobius.waila:wthit:quilt-${wthitVersion}\"\n  modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\"\n}\n</code></pre> <p>Common Project<pre><code>dependencies {\n  modCompileOnly \"mcp.mobius.waila:wthit-api:fabric-${wthitVersion}\"\n}\n</code></pre> Fabric Project<pre><code>dependencies {\n  modRuntimeOnly \"mcp.mobius.waila:wthit:fabric-${wthitVersion}\"\n  modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\"\n}\n</code></pre> Forge Project<pre><code>dependencies {\n  // needed for @WailaPlugin annotation\n  modCompileOnly \"mcp.mobius.waila:wthit-api:forge-${wthitVersion}\"\n  modRuntimeOnly \"mcp.mobius.waila:wthit:forge-${wthitVersion}\"\n  modRuntimeOnly \"lol.bai:badpackets:forge-0.2.0\"\n}\n</code></pre></p> <p>Common Project<pre><code>dependencies {\n  compileOnly \"mcp.mobius.waila:wthit-api:mojmap-${wthitVersion}\"\n}\n</code></pre> Fabric Project<pre><code>dependencies {\n  modRuntimeOnly \"mcp.mobius.waila:wthit:fabric-${wthitVersion}\"\n  modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\"\n}\n</code></pre> Forge Project<pre><code>buildscript {\n  dependencies {\n    classpath \"org.spongepowered:mixingradle:0.7.+\"\n  }\n}\n\napply plugin: \"org.spongepowered.mixin\"\n\ndependencies {\n  // needed for @WailaPlugin annotation\n  compileOnly fg.deobf(\"mcp.mobius.waila:wthit-api:forge-${wthitVersion}\")\n  runtimeOnly fg.deobf(\"mcp.mobius.waila:wthit:forge-${wthitVersion}\")\n  runtimeOnly fg.deobf(\"lol.bai:badpackets:forge-0.2.0\")\n}\n</code></pre> Quilt Project<pre><code>dependencies {\n  modRuntimeOnly \"mcp.mobius.waila:wthit:quilt-${wthitVersion}\"\n  modRuntimeOnly \"lol.bai:badpackets:fabric-0.2.0\"\n}\n</code></pre></p> Why compiling against the API jar? <p>When you compile against the full jar and use non API classes, your mod could break any time WTHIT updates.  On the other hand, the API jar is guaranteed to be stable. No breaking changes without deprecation time.</p> <p>If you found yourself needing to touch non API classes, open an issue on GitHub.</p> Available packages <p>All packages has <code>mcp.mobius.waila</code> as their group.</p> Package Description <code>wthit-api:fabric-${version}</code> Intermediary API jar for Loom projects <code>wthit-api:forge-${version}</code> SRG API jar for ForgeGradle projects <code>wthit-api:quilt-${version}</code> Currently intermediary API jar, would be hashed-mojmap when Quilt supports building it <code>wthit-api:mojmap-${version}</code> Mojang Mappings API jar for VanillaGradle projects <code>wthit:fabric-${version}</code> Full runtime jar for Fabric <code>wthit:forge-${version}</code> Full runtime jar for Forge <code>wthit:quilt-${version}</code> Full runtime jar for Quilt <code>wthit:mojmap-${version}</code> Full platform independent jar for strange people that need access to internal implementations"},{"location":"plugin/getting_started/#creating-plugins","title":"Creating Plugins","text":""},{"location":"plugin/getting_started/#making-a-plugin-class","title":"Making a Plugin Class","text":"<p>Make a class that implements <code>IWailaPlugin</code> <pre><code>public class MyWailaPlugin implements IWailaPlugin {\n@Override\npublic void register(IRegistrar registrar) {\n// register your component here\n}\n}\n</code></pre></p>"},{"location":"plugin/getting_started/#registering-plugins","title":"Registering Plugins","text":"<p>Create a file called <code>waila_plugins.json</code> in the root of your mod, commonly in <code>src/main/resources</code> folder on your project. <pre><code>{\n// the plugin identifier, [namespace:path]\n\"yourmodid:plugin\": {\n// the path to the implementation class\n\"initializer\": \"package.YourWailaPlugin\",\n\n// optional, decide the environment the plugin will loaded, options:\n// client    load plugin only on client and integrated server\n// server    load plugin only on dedicated server\n// *         load plugin on both client and dedicated server\n\"side\": \"*\",\n\n// optional, the required mods that this plugin needs\n\"required\": [\"othermodid\", \"anotherone\"]\n},\n\n// register multiple plugins!\n\"yourmodid:another\": { /*...*/ }\n}\n</code></pre></p>"},{"location":"plugin/overrides/","title":"Overrides","text":"<p>If you have special blocks that shows itself as another block (example: facades), you would want that block to show the imitated block on WTHIT as well.  To do that, you need to register a block override provider.</p>"},{"location":"plugin/overrides/#block-override","title":"Block Override","text":"<p>In this example we wanted to show powder snow block as regular snow block.</p> <p>First create a class that implements <code>IBlockComponentProvider</code> and override the <code>getOverride</code> method. In there you return the block state that you want to immitate into.</p> YarnMojang <pre><code>public class BlockOverride implements IBlockComponentProvider {\n@Override\npublic BlockState getOverride(IBlockAccessor accessor, IPluginConfig config) {\nreturn Blocks.SNOW_BLOCK.getDefaultState();\n}\n}\n</code></pre> <pre><code>public class BlockOverride implements IBlockComponentProvider {\n@Override\npublic BlockState getOverride(IBlockAccessor accessor, IPluginConfig config) {\nreturn Blocks.SNOW_BLOCK.defaultBlockState();\n}\n}\n</code></pre> <p>Then you register the class on your main plugin class. <pre><code>public class MyWailaPlugin implements IWailaPlugin {\n@Override\npublic void register(IRegistrar registrar) {\nregistrar.addOverride(new BlockOverride(), PowderSnowBlock.class);\n}\n}\n</code></pre></p> Priority <p>WTHIT will choose the first override with lower priority number. <code>a &lt;= b ? a : b</code></p>"},{"location":"plugin/overrides/#entity-override","title":"Entity Override","text":"<p>It's also applicable for entities, simply make a class implementing <code>IEntityComponentProvider</code> <pre><code>public class EntityOverride implements IEntityComponentProvider {\n@Override\npublic Entity getOverride(IEntityAccessor accessor, IPluginConfig config) {\nreturn EntityType.SHEEP.create(accessor.getWorld());\n}\n}\n</code></pre></p> <pre><code>public class MyWailaPlugin implements IWailaPlugin {\n@Override\npublic void register(IRegistrar registrar) {\nregistrar.addOverride(new EntityOverride(), PigEntity.class);\n}\n}\n</code></pre> Caching <p>Unlike <code>BlockState</code>, an <code>Entity</code> instance is not cached on any way. This can possibly cause performance issue if you have a many overrides. To mimimalize this, you need to cache it yourself. Since <code>*ComponentProvider</code> is a client-only class, caching based on world and/or position should  be enough for most cases.</p>"}]}